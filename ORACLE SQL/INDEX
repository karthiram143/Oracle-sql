INDEX:
It is used to improve the performance of the query or used
To reduce the cost of the query
-- ex:
SELECT first_ame, salaryfrm employewhere first_name='David';
-- check ins
1.syntactic check- to like from (oracle reserved keyword check) 
2.sematic check - to like 1st check table name,  column names-under the column like to check with right with left check 
ex:salary value is checking if ok it go next in first_name column
3. full scan - If the no index is there it check full scanchecking the CPU cost to checkin scaning using the code
SELECT * FROM c$sql_plan;
 here is lot of data we need to get the v$sql id need to take
--  using
SELECT * FROM V$SQL 
WHERE SQL_TET LIKE ('SELECT first_Name, salaryfr0m employee%');- I am getting sql_id
after 
select * from v$sql_plan where sql_id='dqwvdgwdck6z'; 
TYPE:
 1.B-tree index
 2.bitmap index
 3.composite index
 4.unique index
 5.function based index
 6.index organized table

                --    1.B-tree Index:
1.balanced tree index,(ie) it is an ordered list of values that are divided into range associated with rowed
2.it is crated on high cardinality columns.(like first_name column less duplicate records column using)
-- SYN:
Create INDEX index_name on table_name)column_name);
-- ex:(BEFORE CREATING INDEX)
select FIRST_NAME,SALARY from employee
WHERE FIRST_NAME	='David'

SELECT * FROM V$SQL_PLAN-- CHECK THE COST

SELECT * FROM V$SQL WHERE SQL_TEXT LIKE ('select FIRST_NAME,SALARY from employee
WHERE FIRST_NAME	=''David''%') -- Based on the sql ID TO check the plan after
-- after
SELECT * FROM V$SQL_PLAN where sql_id='depqlsmedmza;'-- here i can able to see the cost
-- RESULT:(ITS SCAN FULL)
COST:3
-- after creating the index
CREATE INDEX INDEX_EMPLOYEE ON EMPLOYEE(FIRST_NAME);--CREATED
-- To checking the what are index are created in this schema
SELECT * FROM user_indexes where TABLE_NAME='EMPLOYEE'
-- RESULT:
INDEX_NAME	INDEX_TYPE	TABLE_OWNER	TABLE_NAME	TABLE_TYPE	UNIQUENESS	COMPRESSION	PREFIX_LENGTH	TABLESPACE_NAME
-- or other To checking the what are index are created in this schema
SELECT * FROM USER_IND_COLUMNS
WHERE TABLE_NAME='EMPLOYEE'
-- RESULT:
INDEX_NAME	TABLE_NAME	COLUMN_NAME	COLUMN_POSITION	COLUMN_LENGTH	CHAR_LENGTH	DESCEND	COLLATED_COLUMN_ID
INDEX_EMPLOYEE	EMPLOYEE	FIRST_NAME	1	50	50	ASC	-

-- AFTER RUNING THE QUERY GIVE THE SAME RESULT:
select FIRST_NAME,SALARY from employee
WHERE FIRST_NAME	='David'

-- RUN THE TO CHECK THE COST
SELECT * FROM V$SQL_PLAN where sql_id='depqlsmedmza;'
-- RESULT:(RANGE SCAN)
COST:1 --TO PERFOMANCE TUING

--** AFTER creating index - it doing asedning to go directly in that place to show the result
SELECT FIRST_NAME FROM EMPLOYEE order by FIRST_NAME asc; --its copying the table

B-TREE STRUCTURE (Employee Names)

                    Emp name A-Z
                   /           \
             A-M                     N-Z
           /     \                 /     \
       A-F       G-M           N-S       T-Z
      /  \      /   \         /   \     /   \
   Rowid Rowid Rowid Rowid Rowid Rowid Rowid Rowid
Explanation:
Root node → Emp name A-Z (top of tree)

Branch nodes → A-M and N-Z (split ranges)

Leaf nodes → A-F, G-M, N-S, T-Z → point to actual ROWIDs

ROWIDs → references to table rows in sorted order

                --    2.Bitmap INDEX
1.Stores the data in a form of bitmap array (ie) stores the indexkey column information along with its rowed
2.it is created on low cardinality columns- like status or gender column last number of duplicate records column using
-- SYN:
Create BITMAP INDEX index_name on table_name (column_name);
-- ex:(BEFORE CREATING INDEX)
select FIRST_NAME from EMP_2
WHERE FIRST_NAME	='David'

SELECT * FROM V$SQL_PLAN-- CHECK THE COST

SELECT * FROM V$SQL WHERE SQL_TEXT LIKE ('select FIRST_NAME from EMP_2
WHERE FIRST_NAME	=''David''%') -- Based on the sql ID TO check the plan after
-- after
SELECT * FROM V$SQL_PLAN where sql_id='depqlsmedmza;'-- here i can able to see the cost
-- RESULT:(ITS SCAN FULL)
COST:3
-- after creating the index
CREATE BITMAP INDEX BITMAP_INDEX_EMP_2 ON EMP_2(GENDER);--CREATED
-- To checking the what are index are created in this schema
SELECT * FROM user_indexes where TABLE_NAME='EMP_2'
-- RESULT:
INDEX_NAME	INDEX_TYPE	TABLE_OWNER	TABLE_NAME	TABLE_TYPE	UNIQUENESS	COMPRESSION	PREFIX_LENGTH	
INDEX_EMP_2	BITMAP	WKSP_KARTHIRAM	EMP_2	TABLE	NONUNIQUE	DISABLED	-	APEX_BIGFILE_INSTANCE_TBS3
-- or other To checking the what are index are created in this schema
SELECT * FROM USER_IND_COLUMNS
WHERE TABLE_NAME='EMP_2'
-- RESULT:
INDEX_NAME	TABLE_NAME	COLUMN_NAME	COLUMN_POSITION	COLUMN_LENGTH	CHAR_LENGTH	DESCEND	COLLATED_COLUMN_ID
INDEX_EMP_2	EMP_2	GENDER	1	1	1	ASC	

-- AFTER RUNING THE QUERY GIVE THE SAME RESULT:
select * from EMP_2
WHERE GENDER IN('M','F')
-- RESULT: why its coming 1st for the gender for F its ordering the gender coluumn in asc
FIRST_NAME	GENDER
Alice	F
Emma	F
Sophia	

-- for this code to check the gender after that go the index checking after it go in table

select count(*) from EMP_2
WHERE GENDER ='M'
-- for this code to check the gender after that go the index checking after it  NOT go in table beacuse it based on bit map index access the index count
-- STRUCUTURE
EMP_2
FIRST_NAME	GENDER
John	M
Alice	F
Robert	M
Emma	F
Michael	M
Row	GENDER	M (bitmap)	F (bitmap)
1	M	1	0
2	F	0	1
3	M	1	0
4	F	0	1
5	M	1	0

                --    3.COMPOSITE INDEX
1.Created on multiple columns in a table
2.it is also called as concatenated index
-- syn:
create INDEX index_name on table_name(column1,…cloumn(n));
-- before create index if anything is there
select * from user_indexes where table_name='EMPLOYEE';
-- EX:
Create index composite_emp on employee (first_name,last_name,employee_id);

SELECT * FROM EMPLOYEE WHERE first_name='Michael' AND LAST_NAME='Brown' AND SALARY='54000'
-- For the index column for 1st column must have the under the where clause is not is not taking -first_name='Michael'- not using it full scaning all the column
SELECT * FROM EMPLOYEE WHERE  LAST_NAME='Brown' AND SALARY='54000'
--  i am createring one more for the index
Create index composite_emp_1 on employee (DEPARTMENT_ID,HIRE_DATE,employee_id);

SELECT * FROM EMPLOYEE WHERE DEPARTMENT_ID=40 AND HIRE_DATE='8/25/2019' AND employee_id='5'
-- For the index column for 1st column must have the under the where clause here it if not department_id that point of time also take the 
-- Index(less distinct values number values are there distinct)
SELECT * FROM EMPLOYEE WHERE HIRE_DATE='8/25/2019' AND employee_id='5'
-- ex: DEPARTMENT_ID is not there for the where clasuse for 1st column DEPARTMENT_ID only few distinct values that point of time take the index composite_emp_1

                --    3.unique index
does not allow duplicate values and allow null values
SYN:
CREATE UNIQUE INDEX index_)name on Table_name (column,(,column2,…));
-- Ex:
CREATE TABLE EMP_8 (ID NUMBER,NAME VARCHAR2(20));
/
CREATE UNIQUE INDEX  unique_indx_emp on  EMP_8 (ID);
/
SELECT * FROM USER_IND_COLUMNS WHERE TABLE_NAME='EMP_8'
/
INSERT INTO EMP_8 VALUES(1,'MANI');-- Rerun the insert i am getting this error (ORA-00001: unique constraint (WKSP_KARTHIRAM.UNIQUE_INDX_EMP) violated)
INSERT INTO EMP_8 VALUES('','MANI'); --it allow null value in many times
/
drop index unique_indx_emp
-- newly created index and name column created index
CREATE UNIQUE INDEX  unique_indx_emp on  EMP_8 (ID,NAME);--Aleady 3 records is there so i am getting error Error at line 1/42: ORA-01452: cannot CREATE UNIQUE INDEX; duplicate keys found
 i trying to insert,
 INSERT INTO EMP_8 VALUES(1,'MANI');
  INSERT INTO EMP_8 VALUES(2,'MANI'); --2 values also insert but is dublicate values is consider like single column 1,mani,  2, main like it take it consider as single it allow
  INSERT INTO EMP_8 VALUES(2,'MANI');-- here is not allowed beacuse 2,mani is aleady there so is not allow to insert

          --  5.FUNCTION BASED INDEX
if an index is created using the function or expression then it is function based index
it can be either  b-tree or bitmap index
-- SYN:
Create index index_name on (table_name (function|expression);
-- ex:(function- aggreate funcation)
select first_name ,length (first_name) from employee
where  length (first_name) =6;
/
create index function_based_indx_emp on employee (first_name);--while using the code and check means is not taking the index
create index function_based_indx_emp_1 on employee (length(first_name));--after checking and run its taking the index

-- - ex:(expression)
select first_name ,salary, salary/2*10 as new_sal from employee
where salary/2*10 >270000;
/
create index function_based_indx_emp_2 on employee(salary/2*10);
-- after checking the and run the code it take the index to use the (** range scan **)
